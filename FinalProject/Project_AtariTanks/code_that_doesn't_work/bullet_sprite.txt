bullet_sprite

`timescale 1ns / 1ps

module bullet_sprite (
    input wire [2:0] row,       // Row index (0 to 7)
    input wire [2:0] col,       // Column index (0 to 7)
    output wire [11:0] bullet_pixel_data // 12-bit RGB value for the pixel
);
    // Bullet sprite: a 3x3 square
    reg [11:0] bullet_sprite_rom [0:8]; // 3x3 = 9 pixels

    // Initialize sprite (this example makes a simple white square)
    initial begin
        bullet_sprite_rom[0] = 12'hFFF;  // White pixel
        bullet_sprite_rom[1] = 12'hFFF; 
        bullet_sprite_rom[2] = 12'hFFF; 
        bullet_sprite_rom[3] = 12'hFFF; 
        bullet_sprite_rom[4] = 12'hFFF;  // Center pixel
        bullet_sprite_rom[5] = 12'hFFF; 
        bullet_sprite_rom[6] = 12'hFFF; 
        bullet_sprite_rom[7] = 12'hFFF; 
        bullet_sprite_rom[8] = 12'hFFF; 
    end

    // Use an always block instead of assign
    assign bullet_pixel_data = bullet_sprite_rom[row * 3 + col]; // Access pixel from ROM
   

endmodule



/// added new logic to control the bullet and the tank 
 always @(posedge clk) begin
    // Default to background (black)
    image_out <= 12'h000;  
    bullet_img_out <= 12'h000; 

    sprite_row <= 3'b000;
    sprite_col <= 3'b000;
    bullet_row <= 2'b00;  // Adjusted for 3x3 bullet
    bullet_col <= 2'b00;

    // Player sprite mapping
    if ((x_in >= x_pos - SIZE/2) && (x_in < x_pos + SIZE/2) &&
        (y_in >= y_pos - SIZE/2) && (y_in < y_pos + SIZE/2)) begin
        sprite_row <= (y_in - (y_pos - SIZE/2)) >> 2;
        sprite_col <= (x_in - (x_pos - SIZE/2)) >> 2;
        image_out <= pixel_data;  
    end 
    // Bullet display
    else if (active && (x_in >= bullet_x - 2) && (x_in < bullet_x + 2) &&
             (y_in >= bullet_y - 2) && (y_in < bullet_y + 2)) begin
        bullet_row <= (y_in - (bullet_y - 2)) >> 1;
        bullet_col <= (x_in - (bullet_x - 2)) >> 1;
        image_out <= bullet_img_out;  // Show bullet
    end
end

